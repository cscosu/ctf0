#!/usr/bin/env python3

'''
Crib-dragging implementation for solving this problem
'''


from binascii import unhexlify
from itertools import combinations


# The given ciphertext
m1 = '0x02 0x00 0x08 0x23 0x38 0x31 0x11 0x2e 0x1e 0x5d 0x48 0x46 0x5d 0x00 0x40 0x5a 0x54 0x12 0x1d 0x09 0x13 0x12 ' \
'0x1b 0x03 0x1e 0x08 0x02 0x47 0x0f 0x5e 0x10 0x43 0x57 0x1e 0x1f 0x56 0x4a 0x49 0x46 0x4f 0x7f 0x35 0x25 0x3e 0x44 ' \
'0x08 0x5a 0x40 0x28 0x19 0x11'

m2 = '0x15 0x3b 0x22 0x1f 0x4b 0x0d 0x19 0x46 0x12 0x10 0x17 0x03 0x53 0x13 0x5c 0x4c 0x11 0x5f 0x0f 0x1f 0x40 0x00 ' \
'0x14 0x09 0x4b 0x06 0x13 0x5d 0x08 0x43 0x44 0x11 0x5b 0x18 0x02 0x14 0x1e 0x06 0x5c 0x42 0x3a 0x61 0x2d 0x3d 0x52 ' \
'0x5f 0x4f 0x53 0x6d 0x4b 0x4d'

m3 = '0x0c 0x36 0x38 0x1f 0x0a 0x03 0x0f 0x15 0x53 0x5c 0x0d 0x0d 0x55 0x41 0x4d 0x50 0x58 0x41 0x4a 0x0d 0x41 0x04 ' \
'0x53 0x1f 0x1e 0x14 0x03 0x5b 0x08 0x49 0x5f 0x5e 0x5e 0x4b 0x0e 0x46 0x1e 0x06 0x46 0x5e 0x7f 0x35 0x24 0x36 0x01 ' \
'0x49 0x44 0x52 0x3b 0x0f 0x1e'


# Convert the strings back into something we can work with
m1 = unhexlify(''.join([b.split('x')[1] for b in m1.split(' ')]))
m2 = unhexlify(''.join([b.split('x')[1] for b in m2.split(' ')]))
m3 = unhexlify(''.join([b.split('x')[1] for b in m3.split(' ')]))

ciphertexts = [m1, m2, m3]

def drag(crib):
    '''
    Drags the given crib along the XOR of each pair of ciphertexts and yields up any ascii results (to use and expand
    for subsequent drags).
    '''

    crib = crib.encode()

    for a, b in combinations(ciphertexts, 2):
        tmp1 = bytearray(len(a))
        for i in range(len(a)):
            tmp1[i] = a[i] ^ b[i]

        for i in range(len(tmp1) - len(crib)):
            tmp2 = bytearray(len(crib))
            for j in range(len(crib)):
                tmp2[j] = tmp1[i + j] ^ crib[j]

            if all(c < 128 for c in tmp2):
                yield tmp2.decode()
